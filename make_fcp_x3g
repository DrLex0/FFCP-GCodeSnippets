#!/bin/bash
# Does post-processing on G-code files generated by PrusaSlicer (Slic3r),
# assuming it has been configured with my custom G-code snippets.
# This script does the following things in this sequence:
# 1. Ensure the final Z move in the end G-code will not destroy your print,
#    and warn about prints exceeding the maximum Z height.
# 2. Either:
#   - IMPORTANT! Fix incorrect second layer temperature command for single
#     extrusion prints, to work around Slic3r bug #4003 / PrusaSlicer #2210;
#     or:
#   - Optionally run the dualstrusion post-processing script if the file has
#     start G-code for dual extrusion.
# 3. Optionally run the MightyVariableFan PWM post-processing script.
# 4. Optionally apply my retraction improver hack.
# 5. Optionally run the G-code file through GPX to produce an x3g file.
#
# This should be called with only a single argument: the G-code file.
# Run with -h for usage info (or just look at usage below).
#
# To use with a Windows WSL environment, create a .BAT file containing the
# following 3 lines, and specify this .BAT file as a post-processing script
# in Slic3r.
#     set fpath=%~1
#     set fpath=%fpath:'='"'"'%
#     bash /your/linux/path/to/make_fcp_x3g -w '%fpath%'
# For this to work, there must be a command `wslpath` inside your Linux
# environment that converts Windows paths to their Linux equivalent. This is
# the case if you use Microsoft's WSL images inside Windows 10 version 1803 or
# newer. In other cases you need to provide your own `wslpath` script.
#
# Version: 20191030
# Alexander Thomas a.k.a. DrLex, https://www.dr-lex.be/
# Thanks to lscotte (https://gitlab.com/lscotte) for help with the WSL stuff
# Released under Creative Commons Attribution 4.0 International license.


### CONFIGURATION STARTS HERE. ############################################
### Modify the following values to match your set-up.
### "Commenting out" a line means prepending it with a hash mark #.
### Similarly, enabling a line is done by removing any leading hash mark.

# Path to the gpx binary. Try `which gpx` if you're not sure what is the
# correct path. To disable conversion to X3G (and leave it up to e.g.
# OctoPrint), comment out this line.
GPX=/usr/local/bin/gpx

# Run `gpx -?` and look at the 'MACHINE' section. If it lists 'fcp' as one of
# the allowed values, it is preferable to use that value here. Otherwise, use
# 'r1d' instead, or something custom if you know what you're doing.
MACHINE=r1d

# The absolutely highest Z value allowed by your printer. This both acts as a
# sanity check and will also update the final Z move in the end G-code when
# necessary. (If you would print something 160mm tall, the default move to 150mm
# must be adjusted to avoid ramming the nozzle into the print.)
# According to official FFCP specs, Z maximum is 150mm and this limit is
# hard-coded in older versions of the Sailfish firmware: it will ignore any
# request to go beyond 150mm. Some newer versions do allow to go beyond this,
# my printer can easily reach 170mm.
# To get the most out of your machine, do a test to see how deep it can go and
# adjust Z_MAX accordingly, as well as 'Max print height' in all your printer
# profiles.
Z_MAX=150

# For the above to work, this must match the comment that marks the final
# Z move in the end G-code.
FINAL_Z_MOVE='; send Z axis to bottom of machine'

# Add extra PATH components here, separated by the usual ':'. You'll need this
# in case some of the scripts require an interpreter (e.g. python3) that is not
# in the stripped-down PATH of Slic3r's environment.
EXTRA_PATH='/usr/local/bin:/usr/local/sbin'

# Set this to 1 to always keep a backup of the unprocessed gcode file,
# regardless of -k option (useful for debugging).
KEEP_ORIG=0

# Set this to 1 to run the sanity check before processing a file and write the
# result to a file 'make_fcp_x3g.check'. This is useful to debug problems when
# invoking make_fcp_x3g from within Slic3r or other programs and not all
# post-processing scripts seem to be working.
DEBUG=0

# The following settings are OPTIONAL. If you do not use any of these scripts,
# leave these lines commented out. Otherwise, set the path in the corresponding
# line and uncomment it. Make sure the file at that path is *executable*
# (chmod a+x).  Mind that incorrect paths or non-executable script files will
# be silently ignored at runtime. Use the sanity check (-c) to ensure you did
# not make any mistakes.

# Path to the dualstrusion post-processing script.
# See https://github.com/DrLex0/DualstrusionPostproc for more information.
#DUALSTRUDE_SCRIPT=/Users/athomas/bin/dualstrusion-postproc.pl

# Path to the PWM postprocessor script in case you would be using the
# MightyVariableFan system, my slightly crazy solution to obtain variable fan
# speed by having the FFCP communicate with a Raspberry Pi through beep sounds.
# See https://github.com/DrLex0/MightyVariableFan for more information.
#PWM_SCRIPT=/Users/athomas/bin/pwm_postprocessor.py

# Extra options to be passed to the PWM_SCRIPT, for instance you may want to
# change options from their defaults, like --allow_split or --zmax.
#PWM_OPTS='--allow_split'

# Path to the (experimental) retraction improver script.
# It also fixes the under-extrusion when starting to print the skirt.
#RETRACT_SCRIPT=/Users/athomas/bin/retraction-improver.pl

############ No user serviceable parts below ############

function usage
{
	local prog=$(basename "$0")
	echo "${prog} [-wPpk] input.gcode   or:   ${prog} -c"
	echo "Processes G-code file for the FFCP with GPX, after optionally applying certain fixes."
	echo "Output will be written to a file with the same name and .x3g extension."
	echo "Options:"
	echo "  -c: performs a sanity check on all configured paths and warns if they do not"
	echo "      point to executable files. (Nothing will be processed even if other"
	echo "      arguments are passed.)"
	echo "  -w: converts Windows file path to a Linux path inside a WSL environment."
	echo "  -P: disables all postprocessing and only runs GPX without -p option."
	echo "  -p: enable -p option of GPX even if -P is used."
	echo "  -k: keep copy of original file."
}


while getopts ':hcwPpk' opt; do
	case $opt in
		h)
			usage
			exit
			;;
		c)
			sanity=1
			;;
		w)
			wsl=1
			;;
		P)
			no_postproc=1
			;;
		p)
			force_progress=1
			;;
		k)
			KEEP_ORIG=1
			;;
		\?)
			echo "Ignoring unknown option: -${OPTARG}" >&2
			;;
	esac
done

if [ -n "${EXTRA_PATH}" ]; then
	export PATH=$(echo "${PATH}" | perl -pe "s;(:|^)/usr/bin:;\1${EXTRA_PATH}:/usr/bin:;")
fi

function sanity_check
{
	local fail try_path

	if [ -n "${GPX}" ]; then
		if [ ! -x "${GPX}" ]; then
			echo "Check failed: the 'GPX' path was specified but does not point to an executable file: ${GPX}"
			fail=1
		elif ! "${GPX}" -? > /dev/null; then
			echo "Check failed: got unexpected result code when running GPX with -? argument."
			fail=1
		elif ! echo 'T0' | "${GPX}" -i -m "${MACHINE}" >/dev/null 2>&1; then
			echo "Check failed: got error when running GPX with '${MACHINE}' machine type. Make sure this is supported. If not, try 'r1d' instead."
			fail=1
		fi
	fi
	if [ -n "${DUALSTRUDE_SCRIPT}" -a ! -x "${DUALSTRUDE_SCRIPT}" ]; then
		echo "Check failed: a 'DUALSTRUDE_SCRIPT' path was specified but does not point to an executable file: ${DUALSTRUDE_SCRIPT}"
		fail=1
	fi
	if [ -n "${PWM_SCRIPT}" ]; then
		if [ ! -x "${PWM_SCRIPT}" ]; then
			echo "Check failed: a 'PWM_SCRIPT' path was specified but does not point to an executable file: ${PWM_SCRIPT}"
			fail=1
		else
			if ! "${PWM_SCRIPT}" -h > /dev/null; then
				echo "Check failed: got unexpected result code when running PWM_SCRIPT with -h argument."
				fail=1
			fi
		fi
	fi
	if [ -n "${RETRACT_SCRIPT}" ]; then
		if [ ! -x "${RETRACT_SCRIPT}" ]; then
			echo "Check failed: a 'RETRACT_SCRIPT' path was specified but does not point to an executable file: ${RETRACT_SCRIPT}"
			fail=1
		else
			if ! "${RETRACT_SCRIPT}" -h > /dev/null; then
				echo "Check failed: got unexpected result code when running RETRACT_SCRIPT with -h argument."
				fail=1
			fi
		fi
	fi
	if grep -qE '(Microsoft|WSL)' /proc/version &> /dev/null; then
		try_path=$(wslpath -a 'C:\\Test\\file.zip')
		if [ $? != 0 -o -z "${try_path}" ]; then
			echo "Check failed: you seem to be inside a WSL environment but the 'wslpath' command is not available or is broken."
			echo "Make sure you have at least Windows 10 version 1803, and 'wslpath' can be run from a bash shell."
			fail=1
		fi
	fi

	if [ -z "${fail}" ]; then
		echo 'All checks seem OK!'
	fi
}


if [ -n "${sanity}" ]; then
	sanity_check
	exit
fi

shift $((OPTIND-1))
inputfile="$1"
if [ -z "${inputfile}" ]; then
	echo "Error: argument should be the path to a .gcode file" >&2
	usage
	exit 2
fi

if [ -n "${wsl}" ]; then
	# Although the conversion between Windows and Linux paths seems trivial, it
	# has many quirks so it is better to rely on the dedicated wslpath tool.
	inputfile=$(wslpath -a "${inputfile}")
	if [ $? != 0 -o -z "${inputfile}" ]; then
		echo "Error: 'wslpath' command not found or failed" >&2
		exit 3
	fi
	echo "Converted Windows path to: '${inputfile}'"
fi

if [ "${DEBUG}" == '1' ]; then
	output=$(dirname "${inputfile}")
	sanity_check > "${output}/make_fcp_x3g.check"
fi

if [ ! -r "${inputfile}" ]; then
	echo "ERROR: input file not found or not readable: ${inputfile}"
	exit 1
fi

arg_p=''
# Avoid using sed, sed in OS X stinks.
origfile=$(echo "${inputfile}" | perl -pe 's/\.gcode$/_orig.gcode/i')
stripped=$(echo "${inputfile}" | perl -pe 's/\.gcode$//i')
warn_file="${stripped}.WARN.txt"
fail_file="${stripped}.FAIL.txt"

function run_script
{
	# Runs a script that prints processed G-code on standard output. If the script exits with an
	# error code, stderr will be written to $fail_file, otherwise anything appearing on stderr is
	# written to $warn_file. The original gcode file is overwritten.
	local name=$1
	local script=$2
	local gcode=$3
	local extra_args=$4

	local tempfile warnings

	echo "Running ${name} script..."
	tempfile=$(mktemp)
	# capture stdout to a file and stderr to a variable
	warnings=$("${script}" $extra_args "${gcode}" 2>&1 >"${tempfile}")
	if [ $? != 0 ] ; then
		if [ -z "${warnings}" ]; then
			warnings="The ${name} script failed, but without any output on stderr."
		fi
		echo "${warnings}" >> "${fail_file}"
		echo "${warnings}" >&2
		rm -f "${tempfile}"
		exit 1
	fi
	[ -n "${warnings}" ] && echo "${warnings}" >> "${warn_file}"
	mv "${tempfile}" "${gcode}"
	chmod 644 "${gcode}"
}

function get_highest_z
{
	# Extract highest Z value in a G1 command from the last 2048 lines of a file.
	local gcode=$1

	tail -n 2048 "${gcode}" | grep -oE '^G1 [^;]*Z[0-9]*\.?[0-9]+' | \
	    awk '{print $2}' | cut -b 2- | sort -g | tail -n 1
}


if [ -z "${no_postproc}" ]; then
	rm -f "${warn_file}" "${fail_file}"

	if [ "${KEEP_ORIG}" == "1" ]; then
		cp -p "${inputfile}" "${origfile}"
	fi

	highest_z=$(get_highest_z "${inputfile}")
	if [ -z "${highest_z}" ]; then
		echo 'WARNING: could not find highest Z coordinate. If this is a valid G-code file, the make_fcp_x3g script needs updating.' >> "${warn_file}"
	else
		if (( $(echo "${highest_z} > ${Z_MAX}" | bc -l) )); then
			echo "WARNING: Z coordinates in this file exceed the maximum: ${highest_z} > ${Z_MAX}. This print will likely end in disaster." >> "${warn_file}"
		fi
		# Find the current final G1 command, its Z value, and transform it if we need to go higher.
		final_move=$(grep "^G1 .*${FINAL_Z_MOVE}" "${inputfile}")
		final_z=$(perl -pe 's/^G1 [^;]*Z(\d*\.?\d+).*$/$1/i' <<< "${final_move}")
		if (( $(echo "${highest_z} > ${final_z}" | bc -l) )); then
			# I know this looks horrible but all it does is replacing the Z coordinate with the new one.
			perl -pi.trashme -e 's/^(G1 [^;]*)Z\d*\.?\d+(.*\Q'"${FINAL_Z_MOVE}"'\E.*)$/$1Z'"${highest_z}"'$2 ; EXTENDED!/i' "${inputfile}"
			rm -f "${inputfile}.trashme"
		fi
	fi

	if [ -x "${DUALSTRUDE_SCRIPT}" ] && grep -q '^;- - - Custom G-code for dual extruder printing' "${inputfile}" 2>/dev/null; then
		run_script 'dualstrusion' "${DUALSTRUDE_SCRIPT}" "${inputfile}"
	elif grep -qE ';- - - Custom G-code for (left|right) extruder printing' "${inputfile}" 2>/dev/null; then
		# Work around bug in Slic3r that always causes T0 to be heated if the second layer has a
		# different filament temperature. See https://github.com/alexrj/Slic3r/issues/4003
		# This hack simply wipes the T argument, which works by the grace of how GPX processes the commands.
		if grep -qE '^M104 S.+ T.+; set temperature$' "${inputfile}"; then
			# I am entirely relying here on the assumption that any version of Slic3r will
			# keep on printing the code with a comment exactly like this.
			echo "Fixing incorrect M104 command for single-extrusion setup"
			perl -pi.trashme -e 's/^M104 S(\S+) (T.*); set temperature$/M104 S$1 ; POSTPROCESS FIX: $2 ARGUMENT REMOVED/' "${inputfile}"
			rm -f "${inputfile}.trashme"
		fi
	fi

	if grep -qE '^M83(;| |$)' "${inputfile}"; then
		# Workaround for issue #60 in gCodeViewer (gcode.ws) that messes up rendering if an M83 is followed by a G90.
		# Again, I'm assuming Slic3r will always print the line exactly like this:
		perl -pi.trashme -e 's/^(G90 ; use absolute coordinates)$/$1\nM83; POSTPROCESS workaround for relative E in gcode.ws/' "${inputfile}"
		rm -f "${inputfile}.trashme"
	fi

	if [ -x "${RETRACT_SCRIPT}" ]; then
		run_script 'retraction' "${RETRACT_SCRIPT}" "${inputfile}"
	fi

	if [ -x "${PWM_SCRIPT}" ]; then
		run_script 'fan PWM post-processing' "${PWM_SCRIPT}" "${inputfile}" $PWM_OPTS
	fi

	# -p overrides % display with something that better approximates total print time than merely
	# mapping the Z coordinate to a percentage. It still is not perfect but at least gives a sensible
	# ballpark figure. For this to work properly, the start GCode block must end with "M73 P1 ;@body"
	# according to typical cargo cult, although a peek in GPX source code reveals that either M73 P1
	# or @body will work.
	arg_p=' -p'
fi

if [ -n "${force_progress}" ]; then
	arg_p=' -p'
fi

if [ -x "${GPX}" ]; then
	# TODO: errors from this command should also be collected. Perhaps filter out the M132
	# warnings, although they should not appear with properly written start code. 
	"${GPX}" $arg_p -m "${MACHINE}" "${inputfile}"
fi
